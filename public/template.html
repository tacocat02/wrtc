<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Chat</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: auto; }
    #chat { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
    #input { width: 100%; margin-top: 10px; padding: 8px; }
    #users { margin: 10px 0; }
    button { margin: 2px 0; }
  </style>
</head>
<body>
  <h2>WebRTC Peer-to-Peer Chat</h2>
  <input id="usernameInput" placeholder="Your name" />
  <button id="connectBtn">Connect</button>
  <div id="users"></div>
  <div id="chat"></div>
  <input id="input" placeholder="Type a message..." disabled />

  <script>
    const serverURL = {{SIGNALING_URL}}; // gets injected by server.js

    const usernameInput = document.getElementById('usernameInput');
    const connectBtn = document.getElementById('connectBtn');
    const usersDiv = document.getElementById('users');
    const chat = document.getElementById('chat');
    const input = document.getElementById('input');

    let username = '';
    let target = '';
    let socket = null;
    let peer = null;
    let dataChannel = null;

    connectBtn.onclick = () => {
      username = usernameInput.value.trim();
      if (!username) return alert("Enter a username");

      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.close();
      }

      socket = new WebSocket(serverURL);

      socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'register', username }));
      };

      socket.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        switch (msg.type) {
          case 'user_list':
            updateUserList(msg.users);
            break;

          case 'offer':
            await handleOffer(msg.offer, msg.from);
            break;

          case 'answer':
            if (peer) await peer.setRemoteDescription(new RTCSessionDescription(msg.answer));
            break;

          case 'candidate':
            if (peer && msg.candidate) {
              await peer.addIceCandidate(new RTCIceCandidate(msg.candidate));
            }
            break;
        }
      };
    };

    function updateUserList(users) {
      usersDiv.innerHTML = "<b>Online users:</b><br>";
      users.filter(u => u !== username).forEach(u => {
        const btn = document.createElement('button');
        btn.textContent = u;
        btn.onclick = () => startConnection(u);
        usersDiv.appendChild(btn);
        usersDiv.appendChild(document.createElement('br'));
      });
    }

    async function startConnection(to) {
      target = to;
      createPeerConnection();

      dataChannel = peer.createDataChannel("chat");
      setupDataChannel();

      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);
      socket.send(JSON.stringify({ type: 'offer', to, offer }));
    }

    async function handleOffer(offer, from) {
      target = from;
      createPeerConnection();

      peer.ondatachannel = (e) => {
        dataChannel = e.channel;
        setupDataChannel();
      };

      await peer.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);
      socket.send(JSON.stringify({ type: 'answer', to: from, answer }));
    }

    function createPeerConnection() {
      if (peer) peer.close();

      peer = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          {
            urls: "turn:192.168.18.13:3478", // your local TURN server IP
            username: "webrtcuser",
            credential: "webrtcpass"
          }
        ]
      });

      peer.onicecandidate = ({ candidate }) => {
        if (candidate) {
          socket.send(JSON.stringify({ type: 'candidate', to: target, candidate }));
        }
      };

      peer.onconnectionstatechange = () => {
        if (peer.connectionState === "connected") {
          log("✅ Peer connection established");
        } else if (["disconnected", "failed", "closed"].includes(peer.connectionState)) {
          input.disabled = true;
          log('⚠️ Connection lost');
        }
      };
    }

    function setupDataChannel() {
      dataChannel.onopen = () => {
        log("✅ DataChannel open");
        input.disabled = false;
      };
      dataChannel.onmessage = (e) => log(`${target}: ${e.data}`);
      dataChannel.onclose = () => log('❌ DataChannel closed');
      dataChannel.onerror = (e) => console.error('DataChannel error:', e);
    }

    input.addEventListener('keydown', e => {
      if (e.key === 'Enter' && input.value.trim() && dataChannel?.readyState === 'open') {
        dataChannel.send(input.value.trim());
        log(`You: ${input.value.trim()}`);
        input.value = '';
      }
    });

    function log(msg) {
      const div = document.createElement('div');
      div.textContent = msg;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }
  </script>
</body>
</html>
