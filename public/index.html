<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Peer-to-Peer Chat</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: auto; }
    #chat { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
    #input { width: 100%; margin-top: 10px; padding: 8px; }
    #users { margin: 10px 0; }
    button { margin: 2px 0; }
  </style>
</head>
<body>
  <h2>WebRTC Peer-to-Peer Chat</h2>
  <input id="usernameInput" placeholder="Your name" />
  <button id="connectBtn">Connect</button>
  <div id="users"></div>
  <div id="chat"></div>
  <input id="input" placeholder="Type a message..." disabled />

  <script>
    window.onload = () => {
      const serverURL = "ws://" + location.hostname + ":3000"; // auto use server IP

      const usernameInput = document.getElementById('usernameInput');
      const connectBtn = document.getElementById('connectBtn');
      const usersDiv = document.getElementById('users');
      const chat = document.getElementById('chat');
      const input = document.getElementById('input');

      let username = '';
      let target = '';
      let socket = null;
      let peer = null;
      let dataChannel = null;

      connectBtn.onclick = () => {
        username = usernameInput.value.trim();
        if (!username) return alert("Enter a username");

        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.close();
        }

        socket = new WebSocket(serverURL);

        socket.onopen = () => {
          console.log('WebSocket connected');
          socket.send(JSON.stringify({ type: 'register', username }));
        };

        socket.onerror = (err) => {
          console.error('WebSocket error:', err);
        };

        socket.onmessage = async (event) => {
          const msg = JSON.parse(event.data);
          console.log('Message received:', msg);

          switch (msg.type) {
            case 'user_list':
              updateUserList(msg.users);
              break;

            case 'offer':
              await handleOffer(msg.offer, msg.from);
              break;

            case 'answer':
              if (peer) {
                await peer.setRemoteDescription(new RTCSessionDescription(msg.answer));
              }
              break;

            case 'candidate':
              if (peer && msg.candidate) {
                await peer.addIceCandidate(new RTCIceCandidate(msg.candidate));
              }
              break;
          }
        };
      };

      function updateUserList(users) {
        usersDiv.innerHTML = "<b>Online users:</b><br>";
        users.filter(u => u !== username).forEach(u => {
          const btn = document.createElement('button');
          btn.textContent = u;
          btn.onclick = () => startConnection(u);
          usersDiv.appendChild(btn);
          usersDiv.appendChild(document.createElement('br'));
        });
      }

      async function startConnection(to) {
        target = to;
        createPeerConnection();

        dataChannel = peer.createDataChannel("chat");
        setupDataChannel();

        const offer = await peer.createOffer();
        await peer.setLocalDescription(offer);
        socket.send(JSON.stringify({ type: 'offer', to, offer }));
      }

      async function handleOffer(offer, from) {
        target = from;
        createPeerConnection();

        peer.ondatachannel = (e) => {
          dataChannel = e.channel;
          setupDataChannel();
        };

        await peer.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peer.createAnswer();
        await peer.setLocalDescription(answer);
        socket.send(JSON.stringify({ type: 'answer', to: from, answer }));
      }

      function createPeerConnection() {
        if (peer) {
          peer.close();
          peer = null;
        }
        peer = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        });

        peer.onicecandidate = ({ candidate }) => {
          if (candidate) {
            socket.send(JSON.stringify({ type: 'candidate', to: target, candidate }));
          }
        };

        peer.onconnectionstatechange = () => {
          console.log('Connection state:', peer.connectionState);
          if (peer.connectionState === "disconnected" || peer.connectionState === "failed" || peer.connectionState === "closed") {
            input.disabled = true;
            log('⚠️ Connection closed or failed');
          }
        };
      }

      function setupDataChannel() {
        dataChannel.onopen = () => {
          log("✅ Chat connected.");
          input.disabled = false;
        };
        dataChannel.onmessage = (e) => log(`${target}: ${e.data}`);
        dataChannel.onclose = () => {
          log('❌ Data channel closed');
          input.disabled = true;
        };
        dataChannel.onerror = (e) => console.error('DataChannel error:', e);
      }

      input.addEventListener('keydown', e => {
        if (e.key === 'Enter' && input.value.trim() && dataChannel && dataChannel.readyState === 'open') {
          dataChannel.send(input.value.trim());
          log(`You: ${input.value.trim()}`);
          input.value = '';
        }
      });

      function log(msg) {
        const div = document.createElement('div');
        div.textContent = msg;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
      }
    };
  </script>
</body>
</html>
